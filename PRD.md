Produktanforderungsdokument (PRD): Autonomes OAK-basiertes Virtuelles Kamerasystem (Projekt "Zero-Dep")1. Executive Summary1.1 ProjektübersichtDas Projekt "Zero-Dep" (Zero Dependency) zielt auf die Entwicklung einer vollständig in sich geschlossenen Windows-Anwendung ab, die Luxonis OAK-Geräte (OpenCV AI Kit) in hochkonfigurierbare virtuelle Webcams transformiert. Im Gegensatz zu herkömmlichen Hardware-UVC-Implementierungen, die oft die fortschrittlichen KI- und Steuerungsfunktionen der Kamera blockieren, setzt dieses Projekt auf eine Host-seitige Software-Bridge. Das Endprodukt ist eine einzige, monolithische Installationsdatei (z.B. Setup.exe), die alle notwendigen Komponenten – einschließlich eines benutzerdefinierten DirectShow-Filters, der Steuerungssoftware, aller Laufzeitbibliotheken und USB-Treiber – bereitstellt.Das Kernversprechen des Projekts ist die absolute Unabhängigkeit von vorinstallierter Software auf dem Zielsystem. Der Endanwender muss weder Python, noch Visual Studio Redistributables, noch komplexe Drittanbietersoftware wie OBS Studio manuell installieren. Die Applikation bietet eine Plug-and-Play-Erfahrung, die professionelle Videokonferenzstandards (Zoom, Microsoft Teams) mit der Flexibilität der OAK-Hardware (On-Device KI, manuelle Fokussteuerung) verbindet.1.2 Problemstellung und MotivationDie Standard-Firmware der OAK-Geräte bietet zwar einen nativen UVC-Knoten (USB Video Class), der es dem Gerät erlaubt, sich als Webcam auszugeben. Umfangreiche technische Analysen zeigen jedoch gravierende Einschränkungen in diesem Modus: Sobald der UVC-Knoten aktiv ist, wird der XLink-Kommunikationskanal – essenziell für die Übertragung von neuronalen Netzwerkedaten und Steuersignalen – häufig blockiert oder instabil.1 Dies resultiert in einem "Entweder-oder"-Szenario: Der Nutzer kann entweder streamen oder die KI-Funktionen steuern, aber selten beides gleichzeitig stabil tun.3Zudem erfordern bestehende Workarounds oft die Installation massiver Softwarepakete wie OBS Studio, um deren virtuelle Kamerafunktion zu nutzen, was für Endanwender eine unzumutbare Hürde darstellt und gegen die Anforderung der "Abhängigkeitsfreiheit" verstößt.41.3 Empfohlene LösungsstrategieUm die Anforderungen an Stabilität, KI-Integration und Installationsfreundlichkeit zu erfüllen, wird eine dreischichtige Architektur empfohlen:Firmware-Ebene: Verzicht auf den nativen UVC-Modus zugunsten des XLink-Modus, um volle Bandbreite für Video und bidirektionale Steuerung zu gewährleisten.Host-Bridge-Applikation: Eine gebündelte Python-Anwendung, die Frames via XLink empfängt, verarbeitet und über Shared Memory weiterleitet.Virtueller DirectShow-Treiber: Ein minimalistischer, MIT-lizenzierter DirectShow-Filter (basierend auf Unity Capture), der als Schnittstelle zu Windows-Anwendungen fungiert.Diese Komponenten werden durch einen Inno Setup-Installer orchestriert, der die Registrierung der Treiberkomponenten (DLLs) und die Installation notwendiger Laufzeitumgebungen vollautomatisch und transparent für den Nutzer abwickelt.2. Detaillierte Problem- und Anforderungsanalyse2.1 Technische Einschränkungen der Hardware-UVC-ImplementierungDie Recherche bestätigt, dass die gleichzeitige Nutzung von UVC-Streaming und XLink-Steuerung auf OAK-Geräten unter Windows systembedingt problematisch ist. Der USB-Controller muss Prioritäten setzen, und der isochrone Transfer für Video (UVC) kollidiert oft mit den Bulk-Transfers für XLink-Daten.1Ressourcenkonflikt: Wenn der UVC-Knoten aktiviert ist, übernimmt der Windows-eigene usbvideo.sys-Treiber die Kontrolle über das Gerät. Versuche, parallel dazu über die depthai-Bibliothek eine XLink-Verbindung aufzubauen, scheitern oft mit Fehlermeldungen wie X_LINK_DEVICE_NOT_FOUND oder Timeout-Fehlern.6Steuerungsverlust: Wichtige Parameter wie manueller Fokus, Belichtungszeit (Exposure) und Weißabgleich können im UVC-Modus oft nicht dynamisch angepasst werden, da der Rückkanal blockiert ist. Dokumentationen zeigen, dass Nutzer, die versuchen, KI-Ergebnisse (z.B. Bounding Boxes) über das UVC-Bild zu legen, auf massive Latenzprobleme oder vollständige Inkompatibilität stoßen.1Format-Limitierungen: Der UVC-Knoten unterstützt primär das NV12-Format. Eine Konvertierung oder Vorverarbeitung auf dem Host ist ohne die XLink-Bridge nicht möglich, was die Flexibilität einschränkt.22.2 Analyse der Virtualisierungstechnologien unter WindowsUm eine Kamera systemweit verfügbar zu machen, muss sie sich in das Windows Multimedia-Framework integrieren. Hierbei stehen drei Hauptpfade zur Verfügung:TechnologieBeschreibungBewertung für Projekt "Zero-Dep"Kernel-Mode Treiber (AVStream)Ein echter Hardware-Treiber auf Kernel-Ebene.Abgelehnt. Erfordert EV-Code-Signing-Zertifikate, ist extrem komplex in der Entwicklung und birgt das Risiko von Bluescreens (BSOD).8Media FoundationDer moderne Nachfolger von DirectShow.Bedingt geeignet. Bietet keine einfache API für virtuelle Quellen ("Virtual Sources") ohne komplexe Treiberentwicklung. Viele Legacy-Apps (z.B. ältere Browser-Stacks) unterstützen dies noch nicht vollständig.8DirectShow Filter (User-Mode)DLL-basierte Filter, die als Videoquelle registriert werden.Empfohlen. Unterstützt von fast allen Konferenz-Apps (Zoom, Teams, Skype). Kann im User-Mode laufen, erfordert kein striktes Kernel-Signing und lässt sich via regsvr32 einfach installieren.11Entscheidung: Das Projekt wird einen DirectShow Source Filter verwenden. Dies ist der De-facto-Standard für virtuelle Kameras (genutzt von OBS, ManyCam, Logi Capture) und bietet die beste Kompatibilität bei geringstem Entwicklungsrisiko.3. Produktdefinition und Funktionsumfang3.1 KernzieleDas Endprodukt muss folgende Attribute aufweisen:Monolithisch: Eine einzige Installationsdatei (.exe), keine manuellen Vorbedingungen.Transparent: Die Kamera erscheint als "OAK Smart Cam" in Windows.Steuerbar: Eine begleitende GUI-App erlaubt die Einstellung von Fokus, ISO und Weißabgleich in Echtzeit.Performant: Latenzzeit unter 200ms ("Lip-Sync"-fähig).3.2 Abgrenzung (Out of Scope)Audio-Routing: Die Übertragung von Audio über den virtuellen Treiber wird explizit ausgeschlossen. Nutzer verwenden das Standard-Mikrofon des Systems oder das OAK-Mikrofon als separates USB-Audio-Gerät. Die Komplexität von virtuellem Audio-Mixing würde den Rahmen des "Zero-Dep"-Ansatzes sprengen.Linux/macOS Support: Aufgrund der spezifischen Anforderung an eine "installierbare Applikation" und der starken Abhängigkeit von der Windows Registry/DirectShow-Architektur konzentriert sich dieses PRD ausschließlich auf Windows 10 und 11.133.3 Zielgruppen-PersonaDer Power-User im Home Office: Benötigt eine Kamera, deren Fokus nicht "pumpt" und deren Belichtung fixiert werden kann, um bei wechselnden Lichtverhältnissen professionell zu wirken.Der industrielle Integrator: Möchte OAK-Kameras in bestehende Windows-basierte Überwachungs- oder Qualitätssicherungssoftware einbinden, die nur DirectShow-Webcams akzeptiert, aber dennoch Zugriff auf KI-Metadaten benötigt.4. Lösungsarchitektur: Das "Host-Bridge"-ModellDie Architektur umgeht die UVC-Limitierungen, indem sie die Kamera im nativen XLink-Modus betreibt und die Webcam-Funktionalität vollständig in Software auf dem Host-PC emuliert.4.1 Architekturdiagramm (Konzeptionell)Code-Snippetgraph TD
    A -- USB 3.0 (XLink) --> B(Host Application / Python)
    B -- Shared Memory (RGB24) --> C(Virtual Driver / DLL)
    C -- DirectShow Interface --> D
    E[User GUI] -- Steuerbefehle --> B
    B -- Control Packets --> A
4.2 Komponente 1: Die OAK-Pipeline (Firmware)Anstatt den UVC-Knoten zu instanziieren, wird eine benutzerdefinierte Pipeline auf das Gerät geladen.Nodes: ColorCamera -> ImageManip (Farbraumkonvertierung/Resizing) -> XLinkOut.Konfiguration:Auflösung: 1080p (1920x1080) oder 720p, je nach Bandbreitenverfügbarkeit.Format: RGB Planar oder Interleaved (Interleaved bevorzugt für direkte Weitergabe).Grund: Die Konvertierung von YUV (NV12) zu RGB ist rechenintensiv. Durch die Nutzung des ImageManip-Knotens auf dem OAK-VPU wird die CPU des Host-PCs entlastet.144.3 Komponente 2: Die Host-Applikation (Der "Controller")Dies ist das Herzstück der Logik. Da keine Abhängigkeiten erlaubt sind, wird diese Komponente in Python entwickelt, aber als Frozen Binary ausgeliefert.Technologie: Python 3.9+, gebündelt mit PyInstaller.Bibliotheken:depthai: Für die Kommunikation mit der Kamera.pyvirtualcam: Als Abstraktionsschicht zum Schreiben in den Shared Memory.PyQt5 oder tkinter: Für das grafische User Interface (GUI).Aufgabe:Initialisiert die Kamera und lädt die Pipeline.Liest Frames aus der XLinkOut-Queue.Schreibt die Frames in den benannten Shared Memory Bereich.Nimmt Benutzereingaben (Slider für Fokus, ISO) entgegen und sendet CameraControl-Nachrichten über XLinkIn an das Gerät.154.4 Komponente 3: Der virtuelle Treiber (DirectShow Filter)Ein minimalistischer C++ Treiber, der sich als Webcam registriert.Basis: Der Quellcode von Unity Capture (MIT Lizenz) wird als Basis empfohlen, da er stabil ist und Shared Memory unterstützt.12Anpassung: Der Treiber muss kompiliert werden, um den Gerätenamen von "Unity Video Capture" in "OAK Smart Cam" zu ändern. Dies verhindert Verwirrung beim Endanwender.Schnittstelle: Er liest kontinuierlich aus dem Shared Memory und präsentiert die Puffer als Video-Frames im RGB24-Format an die anfragende Applikation (z.B. Zoom).5. Detaillierte Anforderungen: Der Virtuelle Treiber (Low-Level)Dieser Abschnitt beschreibt die notwendigen Modifikationen am Open-Source-Treiber, um ihn für das Projekt nutzbar zu machen.5.1 Quellcode-ModifikationenDer originale Unity Capture Treiber ist für Unity-Entwickler gedacht. Für eine White-Label-Lösung sind folgende Änderungen im C++ Code (UnityCaptureFilter.cpp / .h) zwingend:Datei / BereichÄnderungBegründungFilter GUIDsGenerierung neuer GUIDs für CLSID_UnityCapture und CLSID_VirtualCam.Verhindert Konflikte, falls der Nutzer tatsächlich Unity installiert hat.Device NameÄnderung des Strings von "Unity Video Capture" zu "OAK Smart Cam".Professionelles Branding und Klarheit für den Nutzer in Auswahlmenüs.Shared Memory KeyÄnderung des Namensraums von UnityCaptureMemory zu OAKCamMemory.Isolation der Anwendung; verhindert, dass andere Unity-Apps versehentlich in den Videostream schreiben.Registry PfadeAnpassung der Registrierungsschlüssel in DllRegisterServer.Sicherstellung, dass die Konfiguration (z.B. Auflösung) unter einem eigenen Registry-Zweig gespeichert wird.5.2 Build-KonfigurationUm maximale Kompatibilität zu gewährleisten, müssen zwei Versionen der DLL erstellt werden:x64 (64-Bit): Für moderne Anwendungen wie 64-Bit Zoom, Teams und OBS.x86 (32-Bit): Für ältere Anwendungen oder 32-Bit Browser-Instanzen. Auch auf einem 64-Bit Windows können 32-Bit Anwendungen laufen, die zwingend einen 32-Bit DirectShow-Filter benötigen.165.3 Abhängigkeiten des TreibersDer Treiber wird in C++ geschrieben und mit Visual Studio kompiliert. Er hat eine Abhängigkeit zur Microsoft Visual C++ Runtime (VCRedist).Problem: Wenn der Nutzer diese Runtime nicht hat, schlägt die Registrierung der DLL (regsvr32) stillschweigend fehl oder die App stürzt ab.Lösung: Die passende VCRedist (z.B. vc_redist.x64.exe) muss im Installer enthalten sein (siehe Abschnitt 7).6. Detaillierte Anforderungen: Die Host-Applikation6.1 Steuermöglichkeiten (Control Loop)Die Applikation muss eine Echtzeit-Steuerung der Hardware-Parameter ermöglichen. Das OAK-Gerät empfängt diese Befehle asynchron.FeatureTechnische Umsetzung (DepthAI API)User Interface ElementAutofokus Triggerctrl.setAutoFocusMode(dai.CameraControl.AutoFocusMode.AUTO) + ctrl.setAutoFocusTrigger()Button "Fokus jetzt"Manueller Fokusctrl.setManualFocus(lens_position) (0..255)SliderManuelle Belichtungctrl.setManualExposure(exposure_time_us, iso_sensitivity)Zwei Slider (Zeit & ISO) + Checkbox "Auto-Exposure"Weißabgleichctrl.setManualWhiteBalance(color_temp_k) (1000..12000)Slider (Farbtemperatur)Szenen-ModusUmschaltung der Auflösung/Cropping via ImageManipConfigDropdown-Menü (1080p, 720p, Zoom)6.2 GUI-Architektur und ThreadingDa das Auslesen der Videoframes (queue.get()) ein blockierender Vorgang sein kann, darf dies nicht im Haupt-Thread der GUI (Main Loop) geschehen, da sonst die Oberfläche "einfriert".Thread 1 (GUI): Zeichnet Slider und Buttons, empfängt User-Events.Thread 2 (Pipeline): Läuft in einer Endlosschleife.Holt Frame von OAK (q_rgb.get()).Sendet Frame an virtuellen Treiber (cam.send(frame)).Überprüft Queue für Steuerbefehle aus Thread 1 und sendet diese an OAK (q_control.send(ctrl)).Synchronisation: Nutzung von Thread-safe Queues (z.B. Python queue.Queue) zur Kommunikation zwischen GUI und Pipeline-Thread.6.3 Umgang mit VerbindungsabbrüchenOAK-Geräte können durch USB-Wackler oder Standby-Modi die Verbindung verlieren.Anforderung: Die App darf bei X_LINK_ERROR nicht abstürzen.Verhalten:Abbruch der Pipeline-Schleife.Anzeige eines "Connecting..."-Status in der GUI.Der virtuelle Treiber zeigt weiterhin das letzte gültige Frame oder ein generiertes Standbild (z.B. Logo), um den Videostream in Teams nicht abreißen zu lassen.18Hintergrund-Thread pollt nach angeschlossenen Geräten (dai.Device.getAllAvailableDevices()) und reinitialisiert die Pipeline automatisch.7. Packaging und Deployment: Die "Zero-Dependency"-StrategieDies ist der kritischste Teil des Projekts. Um die Anforderung "keine Abhängigkeiten" zu erfüllen, muss der Installer als Container für alle Subsysteme fungieren. Wir verwenden Inno Setup, ein mächtiges, skriptbasiertes Installationssystem für Windows.7.1 Das Installations-Paket (The "Fat" Installer)Der Installer muss folgende Dateien enthalten (gebündelt):Die Host-App: OAK_Controller.exe (erstellt mit PyInstaller).Die Treiber: ZeroDepCam32.dll und ZeroDepCam64.dll.Die Runtimes: vc_redist.x64.exe (Microsoft Visual C++ Redistributable Installer).Hilfsskripte: Falls notwendig für spezifische Registry-Hacks.7.2 Der PyInstaller Build-ProzessPython-Skripte sind nicht nativ ausführbar. PyInstaller verpackt den Python-Interpreter und alle Skripte.Befehl: pyinstaller --noconfirm --onedir --windowed --add-data "assets/*;assets/" main.pyModus: --onedir wird empfohlen. Zwar erzeugt --onefile eine einzelne Datei, diese muss sich aber bei jedem Start temporär entpacken, was den Start verlangsamt und oft zu Problemen mit Virenscannern führt. Inno Setup versteckt den Ordner ohnehin vor dem Nutzer.Hidden Imports: Bibliotheken wie pyvirtualcam laden DLLs dynamisch. Diese müssen explizit in der .spec-Datei definiert werden (binaries=[('Pfad/zu/UnityCapture.dll', '.')]).7.3 Das Inno Setup Skript (Ablauflogik)Das Skript steuert die Sequenz der Installation. Hier ist der präzise Ablauf, um Fehler zu vermeiden:Administrative Rechte: Der Installer muss zwingend als Admin laufen (PrivilegesRequired=admin), da er in C:\Program Files schreibt und globale COM-Objekte registriert.Dateikopie: Alle Dateien werden in {app} (z.B. C:\Program Files\OAK Smart Cam) kopiert.Runtime-Check und Installation:Der Installer prüft über Registry-Keys (HKLM\SOFTWARE\Microsoft\VisualStudio\14.0\VC\Runtimes\x64), ob die VC++ Runtime bereits vorhanden ist.19Falls nein, wird der gebündelte vc_redist.x64.exe mit den Parametern /install /quiet /norestart ausgeführt. Dies garantiert, dass der Nutzer keine Dialoge sieht und die Installation "silent" erfolgt.20Treiber-Registrierung (RegSvr32):Dies ist der Schritt, der die DLLs als DirectShow-Filter anmeldet.Befehl im ``-Abschnitt:DelphiFilename: "regsvr32.exe"; Parameters: "/s ""{app}\Drivers\ZeroDepCam64.dll"""; Flags: runascurrentuser waituntilterminated
Filename: "regsvr32.exe"; Parameters: "/s ""{app}\Drivers\ZeroDepCam32.dll"""; Flags: runascurrentuser waituntilterminated
Das Flag /s (silent) unterdrückt die Erfolgsmeldung ("DllRegisterServer in... succeeded").21Uninstaller:Im ``-Abschnitt müssen die DLLs deregistriert werden (regsvr32.exe /u /s...), bevor die Dateien gelöscht werden. Andernfalls verbleiben "tote" Einträge in der Registry, die Apps wie Zoom zum Absturz bringen können.8. Performance und Ressourcenmanagement8.1 Latenz-Analyse (Glass-to-Glass)Latenz ist der kritische Faktor für die Benutzerakzeptanz.Ziel: < 200 ms.Kette:Sensor-Erfassung (OAK): ~30ms.ISP/VPU Verarbeitung (OAK): ~10-20ms.USB-Transfer (XLink): ~5-10ms (USB 3.0).Host-App (Empfang & Copy to Shared Mem): ~5ms (bei optimiertem Code).Virtual Driver (Read & Present): ~5ms.Konferenz-App (Encoding & Display): Variabel.Optimierung: Die Konvertierung von NV12 zu RGB muss auf dem OAK-Gerät (ImageManip Node) erfolgen. Eine Konvertierung in Python (via NumPy oder OpenCV) würde die CPU-Last drastisch erhöhen und die Latenz um 30-50ms verschlechtern.148.2 Bandbreitenmanagement1080p RGB: 1920 * 1080 * 3 Bytes * 30 FPS ≈ 186 MB/s.USB 3.0 Limit: Realistisch ~350-400 MB/s.Ergebnis: Unkomprimiertes 1080p ist über USB 3.0 machbar.Fallback: Sollte der Nutzer USB 2.0 verwenden (max 35-40 MB/s), reicht die Bandbreite nicht für 1080p unkomprimiert.Lösung: Die App muss die USB-Geschwindigkeit beim Start prüfen (device.getUsbSpeed()). Bei USB 2.0 sollte automatisch auf MJPEG-Encoding auf dem OAK gewechselt werden (VideoEncoder Node), und die Host-App muss das MJPEG dekodieren, bevor es in den Shared Memory geschrieben wird. Dies erhöht die CPU-Last, ermöglicht aber die Nutzung an USB 2.0 Ports.39. Qualitätssicherung und Risikomanagement9.1 Test-MatrixDie Anwendung muss gegen folgende Konfigurationen validiert werden:Test-SzenarioErwartetes ErgebnisClean Install (Win 10/11)Keine Fehlermeldung, VCRedist installiert sich, Kamera sofort in Zoom sichtbar.Upgrade InstallInstaller überschreibt alte Dateien, deregistriert/registriert DLLs korrekt.USB Hot-UnplugApp zeigt "Disconnected", Zoom stürzt nicht ab (zeigt letztes Frame oder Schwarzbild).Multi-App ZugriffApp läuft, Zoom zeigt Video. Nutzer öffnet parallel OBS und wählt denselben Treiber. (Treiber muss Multi-Client Support bieten).Antivirus (Windows Defender)Installation wird nicht blockiert. (Signierung erforderlich).9.2 Sicherheitsaspekte und Code SigningDa die Software Treiberkomponenten installiert und Systemrechte anfordert, wird sie von Windows SmartScreen und Defender aggressiv geprüft.Problem: Unsignierte Installer und DLLs werden oft als "Trojaner" (False Positive) markiert, insbesondere wenn sie Python-Code enthalten (PyInstaller-Problem).24Anforderung:Code Signing Zertifikat: Der Erwerb eines OV (Organization Validation) Zertifikats ist quasi zwingend.Signierungsprozess: Sowohl die .dll Dateien, die .exe der Host-App als auch der finale Setup.exe Installer müssen signiert werden (signtool.exe).Submission: Für optimale Reputation empfiehlt sich die Einreichung bei Microsoft zur Analyse, um Defender-Warnungen proaktiv zu verhindern.9.3 Datenschutz-ComplianceDa es sich um eine Kameraanwendung handelt, gelten besondere Transparenzanforderungen.Indikator: Die Anwendung muss deutlich anzeigen, wenn die Kamera aktiv ist (Preview-Fenster oder Tray-Icon-Status).Datenfluss: Es muss garantiert werden, dass die Videodaten den lokalen PC nicht verlassen (außer durch die explizite Weitergabe an die Konferenz-Software). Keine Telemetrie-Daten an Luxonis oder den Entwickler ohne explizite Zustimmung (Opt-In).10. Implementierungsplan (Roadmap)Phase 1: Treiber-Vorbereitung (Woche 1-2)Forken des Unity Capture Repositories.Umbenennung der Strings und GUIDs ("OAK Smart Cam").Kompilierung der x86 und x64 Release-DLLs.Manuelles Testen der Registrierung mit regsvr32.Phase 2: Host-App Prototyp (Woche 3-4)Entwicklung des Python-Skripts mit depthai Pipeline.Implementierung der pyvirtualcam Anbindung an den umbenannten Treiber.Basis-GUI für Belichtungssteuerung.Validierung der Latenz und Stabilität.Phase 3: Installer & Packaging (Woche 5)Erstellung des PyInstaller Specs (Bundling der Assets).Schreiben des Inno Setup Skripts (Logik für VCRedist, RegSvr32).Erste Tests auf "jungfräulichen" VMs.Phase 4: Optimierung & Signierung (Woche 6)Implementierung des USB 2.0 Fallbacks (MJPEG).Kauf und Anwendung des Code Signing Zertifikats.End-to-End Tests mit Zoom, Teams, Skype.11. FazitDas Projekt "Zero-Dep" löst ein fundamentales Problem der OAK-Ökosystems: Die Unvereinbarkeit von UVC-Komfort und KI-Flexibilität. Durch die strategische Entscheidung, den Hardware-UVC-Modus zu umgehen und stattdessen eine Software-Bridge zu nutzen, erhalten Nutzer das Beste aus beiden Welten.Der Schlüssel zum Erfolg liegt nicht in der Python-Programmierung, sondern in der Installations-Orchestrierung. Die nahtlose, stille Installation der Laufzeitumgebungen und die korrekte Registrierung der DirectShow-Filter unterscheiden dieses Produkt von basteligen GitHub-Skripten und machen es zu einer professionell einsetzbaren Lösung für Endanwender. Die strikte Einhaltung der "Zero-Dependency"-Doktrin stellt sicher, dass die Anwendung auf jedem modernen Windows-Rechner "out of the box" funktioniert, ohne dass der Nutzer technische Hürden überwinden muss.Anhang: Technische ReferenzdatenInno Setup Snippet (Konzept):Delphi; Dies ist ein Auszug aus dem empfohlenen Inno Setup Skript

AppName=OAK Smart Cam
DefaultDirName={commonpf}\OAK Smart Cam
PrivilegesRequired=admin
ArchitecturesInstallIn64BitMode=x64

[Files]
; Die Hauptanwendung (gebündelt)
Source: "dist\OAK_Controller\*"; DestDir: "{app}"; Flags: ignoreversion recursesubdirs
; Die Treiber
Source: "drivers\ZeroDepCam64.dll"; DestDir: "{app}\drivers"; Flags: ignoreversion
Source: "drivers\ZeroDepCam32.dll"; DestDir: "{app}\drivers"; Flags: ignoreversion
; Die Runtime
Source: "redist\vc_redist.x64.exe"; DestDir: "{tmp}"; Flags: deleteafterinstall


; Silent Installation der Runtime
Filename: "{tmp}\vc_redist.x64.exe"; Parameters: "/install /quiet /norestart"; StatusMsg: "Installiere Systemkomponenten..."; Check: VCRedistNeedsInstall
; Registrierung der Treiber
Filename: "regsvr32.exe"; Parameters: "/s ""{app}\drivers\ZeroDepCam64.dll"""; StatusMsg: "Registriere 64-Bit Treiber..."; Flags: runascurrentuser
Filename: "regsvr32.exe"; Parameters: "/s ""{app}\drivers\ZeroDepCam32.dll"""; StatusMsg: "Registriere 32-Bit Treiber..."; Flags: runascurrentuser


; Deregistrierung vor dem Löschen
Filename: "regsvr32.exe"; Parameters: "/u /s ""{app}\drivers\ZeroDepCam64.dll"""; Flags: runascurrentuser
Filename: "regsvr32.exe"; Parameters: "/u /s ""{app}\drivers\ZeroDepCam32.dll"""; Flags: runascurrentuser
Registry Keys für Virtual Camera Detection:32-Bit Treiber: HKEY_CLASSES_ROOT\WOW6432Node\CLSID\{GUID}\Instance64-Bit Treiber: HKEY_CLASSES_ROOT\CLSID\{GUID}\InstanceVideo Input Category GUID: {860BB310-5D01-11d0-BD3B-00A0C911CE86}